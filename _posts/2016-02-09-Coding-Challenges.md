---
layout: post
title: Classic Coding Challenges
---

---
Coding challenges are a part of life for any developer, whether you are a student, interviewer, or interviewee. It's important to know how to approach these challenges and not be intimidated by them, and you can become a much better problem solver in the process. I, for one, enjoy puzzles and genuinely like coding challenges, whether they have any real-world application or not. So here's my 5 steps to coding challenges:

###1: Do not Google the problem
"Why not!?" you think. After all, that's how programmers figure out pretty much anything. Haven't memorized that quirky method? Google it. Strange error you've never seen before? Google it! Wifi down? Google it!

Learning how to search efficiently for answers to your programming questions via Google is an essential skill. After all, languages, frameworks, and software are constantly being updated, and you never know when something that was working yesterday decides to break today. But coding challenges are one area where you don't want to Google the answer.

For one, the answer is pretty much guaranteed to be out there, as the solutions to these problems are not state secrets. They've been done many times over. Once you see the answer, you've ruined your innocence and whatever unique approach you may have brought to the problem. Or worse, you find an overly elegant solution that uses methods and logic you wouldn't have dreamed of using, and you don't understand how it works.

It's best to resist the urge to Google the answer, even when you are stuck. These are challenges. They are meant to be hard, and are designed to take a long time to solve. You're meant to struggle!

###2: Do start coding ASAP
Start writing code, or better yet pseudocode, as soon as you can. Even if you don't really have a good idea how to solve the whole problem, you most likely know where to start, what variables or methods might needed, etc. The longer you just stare at a problem and think about it, the more daunting it becomes. Take a minute to gather your thoughts, and then write the pseudocode, in steps, of what you need the program to achieve. I find once I start writing pseudocode, it becomes more apparent how the logic of the program will work and what methods I could use. Basically, the sooner your start typing, the better. Programs don't write themselves as you are deep in thought...

###3: Get it working quickly, no matter how ugly
I once looked and thought about a coding challenge for an hour before I started typing any code whatsoever. I felt like I was trying to get through a concrete wall of algorithms. But once I started writing my solution, it became apparent that I had been drastically over thinking the problem at hand. So, get your code working as quickly as possible, no matter how ugly or inefficient it may seem. The great thing is, once your code is working error free and returning the desired results, you know you've solved (most) of the problem! Now you can go back and clean up your code, add missing comments, and possibly refractor. 

###4: Write your solution in another language
Now that you've got your program working, you're probably feeling pretty triumphant. You also probably wrote your solution in the language you're most comfortable in. To bring your ego back to Earth, a good exercise is to recreate your solution in another language that you work in, but are not as fluent in. I find this helps to keep all your skills sharp, and I often discover a good way to refractor the code along the way. If you're really good, you'll write each solution using the chosen language's strengths.

###5: Now have fun
Now you can have fun with your code. Revise it, check for edge cases, try to make your program crash, and upload it in all its glory to [Github](https://github.com/richardmable/classicCodeProblems). Now is also a good time to Google the coding challenge you have just solved, and read what other people came up with. Try to find an overly elegant solution and understand what it's doing. I'll leave you with my personal favorite, which is over thinking [FizzBuzz](http://chalain.livejournal.com/68788.html).
